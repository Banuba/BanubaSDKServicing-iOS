// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name BanubaSDKServicing
import ARKit
import AVFoundation
import AVKit
import CoreMedia
import Foundation
import Swift
import UIKit
public protocol EffectSubtypeModificationsEventListener : AnyObject {
  func didChangeEffectSubtype(_ subtypeName: Swift.String)
  func didInitiateEffectSubtype(_ subtypeName: Swift.String)
}
public protocol SDKEffectsTextureServicing {
  func effectAddImageTexture(image: UIKit.UIImage)
  func effectAddVideoTexture(asset: AVFoundation.AVURLAsset)
  func unloadEffectTexture()
}
public protocol SDKEffectsServicing : AnyObject, BanubaSDKServicing.SDKEffectsTextureServicing {
  func loadMask(name: Swift.String)
  func effectDidBeginApplying()
  func effectDidEndApplying()
  func effectDidResetApplying()
  func effectDidChangeState()
  func unloadMask()
  func removeAllFilters()
  func applyFilter(_ filter: BanubaSDKServicing.EffectModel)
  func removeFilter(_ filter: BanubaSDKServicing.EffectModel)
  func setEffectSubtypeModificationsEventListener(_ listener: BanubaSDKServicing.EffectSubtypeModificationsEventListener)
  func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
}
public protocol EffectsServicing {
  func apply(effect: BanubaSDKServicing.RenderEffect)
  func remove(effect: BanubaSDKServicing.RenderEffect)
  func removeAll()
}
public class BeautyEffectManager : BanubaSDKServicing.BeautyEffectManaging {
  public var applyHandler: ((Swift.String?) -> Swift.Void)?
  public var enabled: Swift.Bool {
    get
    set(value)
  }
  public init()
  public func enable()
  public func disable()
  @objc deinit
}
public protocol SDKOutputServicing : AnyObject {
  var isRecording: Swift.Bool { get }
  var isEnoughDiskSpaceForRecording: Swift.Bool { get }
  func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func stopVideoCapturing(cancel: Swift.Bool)
}
public protocol BeautyEffectManaging {
  var enabled: Swift.Bool { get set }
  var applyHandler: ((Swift.String?) -> Swift.Void)? { get set }
}
public protocol RenderEffect : AnyObject {
  var name: Swift.String { get }
  var isLoaded: Swift.Bool { get }
  var isActive: Swift.Bool { get set }
  func load(size: CoreGraphics.CGSize)
  func unload()
  func apply(params: Swift.Dictionary<Swift.String, Swift.String>)
}
public enum PIPShapeTypeAdapter {
  case none
  case oval
  case circle
  case roundRect(radius: CoreGraphics.CGFloat)
  case roundSquare(radius: CoreGraphics.CGFloat)
}
public enum RenderBehaviorAdapter {
  case fullScreen
  case verticalSplitUp
  case verticalSplitDown
  case horizontalSplitLeft
  case horizontalSplitRight
  case pip
  public static func == (a: BanubaSDKServicing.RenderBehaviorAdapter, b: BanubaSDKServicing.RenderBehaviorAdapter) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SDKPIPServicing {
  var pipRenderSize: CoreGraphics.CGSize { get }
  func seekPIPPlayer(to time: Foundation.TimeInterval)
  func resetPIPShape()
  func createPIPPlayer(withVideoURL url: Foundation.URL, completion: (() -> Swift.Void)?)
  func startPIPPlayer()
  func stopPIPPlayer()
  func setPIPPlayer(renderBehaviour: BanubaSDKServicing.RenderBehaviorAdapter)
  func setPIPPlayer(shapeType type: BanubaSDKServicing.PIPShapeTypeAdapter)
  func setPIPPlayer(centerPoint point: CoreGraphics.CGPoint)
}
public enum CameraModuleSessionType {
  case frontVideo
  case backVideo
  case frontPhoto
  case backPhoto
  public static func == (a: BanubaSDKServicing.CameraModuleSessionType, b: BanubaSDKServicing.CameraModuleSessionType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct CameraModulePhotoSettings {
  public let useStabilization: Swift.Bool
  public let flashMode: AVFoundation.AVCaptureDevice.FlashMode
  public init(useStabilization: Swift.Bool, flashMode: AVFoundation.AVCaptureDevice.FlashMode)
}
public struct CameraModuleDefaults {
  public static var viewSize: CoreGraphics.CGSize {
    get
  }
}
public protocol CameraModule : BanubaSDKServicing.SDKBeautyEffectManaging, BanubaSDKServicing.SDKEffectsServicing, BanubaSDKServicing.SDKInputServicing, BanubaSDKServicing.SDKMaskPostprocessServicing, BanubaSDKServicing.SDKOutputServicing, BanubaSDKServicing.SDKPIPServicing {
  var isLoaded: Swift.Bool { get }
  var allowProcessing: Swift.Bool { get set }
  var playerViewSize: CoreGraphics.CGSize { get }
  var autoStart: Swift.Bool { get set }
  func setup(postproccessContext: OpenGLES.EAGLContext)
  func destroy()
  func start(completion: @escaping () -> Swift.Void)
  func stop(completion: (() -> Swift.Void)?)
  func setRenderTarget(view: UIKit.UIView)
  func removeRenderTarget()
  func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  func getRendererView() -> UIKit.UIView
}
public class EffectModel {
  public var url: Foundation.URL?
  public var name: Swift.String?
  public init(url: Foundation.URL)
  public init(name: Swift.String)
  @objc deinit
}
public protocol SDKMaskPostprocessServicing : AnyObject {
  func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  func postprocessStopVideoProcessing()
  func postprocessPlaybackStop()
  func postprocessSurfaceDestroyed()
  func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  func postprocessLoadEffect(path: Swift.String)
  func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  func postprocessDraw()
}
public enum OutputServiceError : Swift.Error {
  case notEnoughSpace
  public static func == (a: BanubaSDKServicing.OutputServiceError, b: BanubaSDKServicing.OutputServiceError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SDKBeautyEffectManaging : AnyObject {
  var isBeautificationEnabled: Swift.Bool { get set }
  func toggleBeautification() -> Swift.Bool
}
public protocol SDKInputServicingDelegate {
  func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public protocol SDKARInputServicingDelegate {
  func didUpdate(arFrame: ARKit.ARFrame, session: ARKit.ARSession)
  func didAdd(anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
  func didUpdate(anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
  func didRemove(didRemove anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
}
public protocol SDKInputServicing : AnyObject {
  var isFrontCamera: Swift.Bool { get }
  var zoomFactor: Swift.Float { get }
  var currentCameraSessionType: BanubaSDKServicing.CameraModuleSessionType { get }
  var inputDelegate: BanubaSDKServicing.SDKInputServicingDelegate? { get set }
  var inputARDelegate: BanubaSDKServicing.SDKARInputServicingDelegate? { get set }
  func configureExposureSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func configureFocusSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  func toggleCamera(completion: @escaping () -> ())
  func startCamera()
  func startAudioCapturing()
  func stopAudioCapturing()
  func setCameraSessionType(_ type: BanubaSDKServicing.CameraModuleSessionType)
  @discardableResult
  func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
}
